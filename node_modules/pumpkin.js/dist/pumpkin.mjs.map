{"version":3,"file":"pumpkin.mjs","sources":["../src/pumpkin.js"],"sourcesContent":["/**\n * Get an element in the DOM\n * @param  {String} selector The selector to match against\n * @param  {Node} scope      An element to search within [optional]\n * @return {Node}            The first matching element\n */\nexport const qs = (selector, scope = document) => scope.querySelector(selector)\n\n/**\n * Get all matching elements in the DOM\n * @param  {String} selector The selector to match against\n * @param  {Node} scope      An element to search within [optional]\n * @return {Array}           The matching elements (as an array)\n */\nexport const qsa = (selector, scope = document) =>\n  [].slice.call(scope.querySelectorAll(selector))\n\n/**\n * Get the first item(s) in an array\n * @param  {Array} array     The array to select from\n * @param  {Number} count    The number of items to retrieve [optional]\n * @param  {Boolean} reverse Whether to reverse the returned array [optional]\n * @return {Any}             Either first item or an array of first x items\n */\nexport const first = (array, count, reverse) => {\n  if (!count) return array[0]\n\n  let newArray = []\n  for (let i = 0; i < count; i++) newArray.push(array[i])\n  return reverse ? newArray.reverse() : newArray\n}\n\n/**\n * Get the last item(s) in an array\n * @param  {Array} array     The array to select from\n * @param  {Number} count    The number of items to retrieve [optional]\n * @param  {Boolean} reverse Whether to reverse the returned array [optional]\n * @return {Any}             Either last item or an array of last x items\n */\nexport const last = (array, count, reverse) => {\n  if (!count) return array[array.length - 1]\n\n  let newArray = []\n  for (let i = 1; i <= count; i++) newArray.push(array[array.length - i])\n  return reverse ? newArray : newArray.reverse()\n}\n\n/**\n * Remove value(s) from an array\n * @param  {Array} array The array to select from\n * @param  {Any} values  The values to remove\n * @return {Array}       The new array\n */\nexport const strip = (array, ...values) => {\n  values.forEach(value => {\n    array = array.filter(item => item !== value)\n  })\n  return array\n}\n\n/**\n * Get the children of an element\n * @param  {Node} el The element to search\n * @return {Array}   The children of the passed element\n */\nexport const children = el => {\n  let children = []\n  for (let i = el.children.length; i--; ) {\n    if (el.children[i].nodeType != 8) children.unshift(el.children[i])\n  }\n  return children\n}\n\n/**\n * Get the siblings of an element\n * @param  {Node} el The element to search\n * @return {Array}   The siblings of the passed element\n */\nexport const siblings = el => {\n  let siblings = Array.prototype.slice.call(el.parentNode.children)\n  for (let i = siblings.length; i--; ) {\n    if (siblings[i] === el) {\n      siblings.splice(i, 1)\n      break\n    }\n  }\n  return siblings\n}\n\n/**\n * Check if element contains child\n * @param  {Node} el    The element to search\n * @param  {Node} child The child element to search for\n * @return {Boolean}    Whether or not child was found\n */\nexport const contains = (el, child) => el !== child && el.contains(child)\n\n/**\n * Removes all children from element\n * @param {Node} el The element to empty\n */\nexport const empty = el => {\n  while (el.firstChild) el.removeChild(el.firstChild)\n}\n\n/**\n * Remove element from the DOM\n * @param {Node} el The element to remove\n */\nexport const remove = el => {\n  el.parentNode.removeChild(el)\n}\n\n/**\n * Get the distance between an element and the top of the page\n * @param  {Node} el The element to check\n * @return {Number}  The distance from the top of the page\n */\nexport const fromTop = el => el.getBoundingClientRect().top + window.scrollY\n\n/**\n * Show selected element\n * @param {Node} el The element to show\n */\nexport const show = el => {\n  el.style.display = ''\n}\n\n/**\n * Hide selected element\n * @param {Node} el The element to hide\n */\nexport const hide = el => {\n  el.style.display = 'none'\n}\n\n/**\n * Toggle visibility of selected element\n * @param {Node} el The element to toggle\n */\nexport const toggle = el => {\n  el.style.display = el.style.display == 'none' ? '' : 'none'\n}\n\n/**\n * Apply multiple inline styles to an element\n * @param {Node} el    The element to apply the styles to\n * @param {Object} obj An object of CSS rules\n */\nexport const css = (el, obj) => {\n  for (let rule in obj) {\n    el.style[rule] = obj[rule]\n  }\n}\n\n/**\n * Apply propagating event handlers\n * @param {String} event    The event to trigger on\n * @param {Array} array     The array of nodes to apply to\n * @param {String} selector Query selector for event to bind to [optional]\n * @param {Function} cb     The function to run upon event trigger\n */\nexport const on = (event, array, selector, cb) => {\n  cb = typeof selector === 'function' ? selector : cb\n  array = array.length ? array : [array]\n\n  const listener = function(e) {\n    if (typeof selector === 'string') {\n      if (e.target.closest(selector)) {\n        cb.apply(e.target.closest(selector), [e])\n      }\n    } else {\n      cb.apply(this, [e])\n    }\n  }\n\n  array.forEach(item => {\n    item.addEventListener(event, listener)\n  })\n}\n\n/**\n * Run callback function once DOM has fully loaded\n * @param {Function} cb The function to run once ready\n */\nexport const ready = cb => {\n  if (document.readyState != 'loading') cb()\n  else if (document.addEventListener)\n    document.addEventListener('DOMContentLoaded', cb)\n  else\n    document.attachEvent('onreadystatechange', () => {\n      if (document.readyState == 'complete') cb()\n    })\n}\n"],"names":["qs","selector","scope","document","querySelector","qsa","slice","call","querySelectorAll","first","array","count","reverse","let","newArray","i","push","last","length","strip","values","forEach","value","filter","item","children","el","nodeType","unshift","siblings","Array","prototype","parentNode","splice","contains","child","empty","firstChild","removeChild","remove","fromTop","getBoundingClientRect","top","window","scrollY","show","style","display","hide","toggle","css","obj","rule","on","event","cb","const","listener","e","target","closest","apply","this","addEventListener","ready","readyState","attachEvent"],"mappings":"AAMO,IAAMA,WAAMC,EAAUC,yBAAQC,UAAaD,EAAME,cAAcH,IAQzDI,WAAOJ,EAAUC,yBAAQC,aACjCG,MAAMC,KAAKL,EAAMM,iBAAiBP,KAS1BQ,WAASC,EAAOC,EAAOC,GAClC,IAAKD,EAAO,OAAOD,EAAM,GAGzB,IADAG,IAAIC,KACKC,EAAI,EAAGA,EAAIJ,EAAOI,IAAKD,EAASE,KAAKN,EAAMK,IACpD,OAAOH,EAAUE,EAASF,UAAYE,GAU3BG,WAAQP,EAAOC,EAAOC,GACjC,IAAKD,EAAO,OAAOD,EAAMA,EAAMQ,OAAS,GAGxC,IADAL,IAAIC,KACKC,EAAI,EAAGA,GAAKJ,EAAOI,IAAKD,EAASE,KAAKN,EAAMA,EAAMQ,OAASH,IACpE,OAAOH,EAAUE,EAAWA,EAASF,WAS1BO,WAAST,iEAIpB,OAHAU,EAAOC,iBAAQC,GACbZ,EAAQA,EAAMa,gBAAOC,UAAQA,IAASF,MAEjCZ,GAQIe,WAAWC,GAEtB,IADAb,IAAIY,KACKV,EAAIW,EAAGD,SAASP,OAAQH,KACA,GAA3BW,EAAGD,SAASV,GAAGY,UAAeF,EAASG,QAAQF,EAAGD,SAASV,IAEjE,OAAOU,GAQII,WAAWH,GAEtB,IADAb,IAAIgB,EAAWC,MAAMC,UAAUzB,MAAMC,KAAKmB,EAAGM,WAAWP,UAC/CV,EAAIc,EAASX,OAAQH,KAC5B,GAAIc,EAASd,KAAOW,EAAI,CACtBG,EAASI,OAAOlB,EAAG,GACnB,MAGJ,OAAOc,GASIK,WAAYR,EAAIS,UAAUT,IAAOS,GAAST,EAAGQ,SAASC,IAMtDC,WAAQV,GACnB,KAAOA,EAAGW,YAAYX,EAAGY,YAAYZ,EAAGW,aAO7BE,WAASb,GACpBA,EAAGM,WAAWM,YAAYZ,IAQfc,WAAUd,UAAMA,EAAGe,wBAAwBC,IAAMC,OAAOC,SAMxDC,WAAOnB,GAClBA,EAAGoB,MAAMC,QAAU,IAORC,WAAOtB,GAClBA,EAAGoB,MAAMC,QAAU,QAORE,WAASvB,GACpBA,EAAGoB,MAAMC,QAA8B,QAApBrB,EAAGoB,MAAMC,QAAoB,GAAK,QAQ1CG,WAAOxB,EAAIyB,GACtB,IAAKtC,IAAIuC,KAAQD,EACfzB,EAAGoB,MAAMM,GAAQD,EAAIC,IAWZC,WAAMC,EAAO5C,EAAOT,EAAUsD,GACzCA,EAAyB,mBAAbtD,EAA0BA,EAAWsD,EAGjDC,IAAMC,EAAW,SAASC,GACA,iBAAbzD,EACLyD,EAAEC,OAAOC,QAAQ3D,IACnBsD,EAAGM,MAAMH,EAAEC,OAAOC,QAAQ3D,IAAYyD,IAGxCH,EAAGM,MAAMC,MAAOJ,MARpBhD,EAAQA,EAAMQ,OAASR,GAASA,IAY1BW,iBAAQG,GACZA,EAAKuC,iBAAiBT,EAAOG,MAQpBO,WAAQT,GACQ,WAAvBpD,SAAS8D,WAAyBV,IAC7BpD,SAAS4D,iBAChB5D,SAAS4D,iBAAiB,mBAAoBR,GAE9CpD,SAAS+D,YAAY,gCACQ,YAAvB/D,SAAS8D,YAA0BV"}