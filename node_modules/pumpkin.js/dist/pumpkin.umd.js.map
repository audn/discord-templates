{"version":3,"file":"pumpkin.umd.js","sources":["../src/pumpkin.js"],"sourcesContent":["/**\n * Get an element in the DOM\n * @param  {String} selector The selector to match against\n * @param  {Node} scope      An element to search within [optional]\n * @return {Node}            The first matching element\n */\nexport const qs = (selector, scope = document) => scope.querySelector(selector)\n\n/**\n * Get all matching elements in the DOM\n * @param  {String} selector The selector to match against\n * @param  {Node} scope      An element to search within [optional]\n * @return {Array}           The matching elements (as an array)\n */\nexport const qsa = (selector, scope = document) =>\n  [].slice.call(scope.querySelectorAll(selector))\n\n/**\n * Get the first item(s) in an array\n * @param  {Array} array     The array to select from\n * @param  {Number} count    The number of items to retrieve [optional]\n * @param  {Boolean} reverse Whether to reverse the returned array [optional]\n * @return {Any}             Either first item or an array of first x items\n */\nexport const first = (array, count, reverse) => {\n  if (!count) return array[0]\n\n  let newArray = []\n  for (let i = 0; i < count; i++) newArray.push(array[i])\n  return reverse ? newArray.reverse() : newArray\n}\n\n/**\n * Get the last item(s) in an array\n * @param  {Array} array     The array to select from\n * @param  {Number} count    The number of items to retrieve [optional]\n * @param  {Boolean} reverse Whether to reverse the returned array [optional]\n * @return {Any}             Either last item or an array of last x items\n */\nexport const last = (array, count, reverse) => {\n  if (!count) return array[array.length - 1]\n\n  let newArray = []\n  for (let i = 1; i <= count; i++) newArray.push(array[array.length - i])\n  return reverse ? newArray : newArray.reverse()\n}\n\n/**\n * Remove value(s) from an array\n * @param  {Array} array The array to select from\n * @param  {Any} values  The values to remove\n * @return {Array}       The new array\n */\nexport const strip = (array, ...values) => {\n  values.forEach(value => {\n    array = array.filter(item => item !== value)\n  })\n  return array\n}\n\n/**\n * Get the children of an element\n * @param  {Node} el The element to search\n * @return {Array}   The children of the passed element\n */\nexport const children = el => {\n  let children = []\n  for (let i = el.children.length; i--; ) {\n    if (el.children[i].nodeType != 8) children.unshift(el.children[i])\n  }\n  return children\n}\n\n/**\n * Get the siblings of an element\n * @param  {Node} el The element to search\n * @return {Array}   The siblings of the passed element\n */\nexport const siblings = el => {\n  let siblings = Array.prototype.slice.call(el.parentNode.children)\n  for (let i = siblings.length; i--; ) {\n    if (siblings[i] === el) {\n      siblings.splice(i, 1)\n      break\n    }\n  }\n  return siblings\n}\n\n/**\n * Check if element contains child\n * @param  {Node} el    The element to search\n * @param  {Node} child The child element to search for\n * @return {Boolean}    Whether or not child was found\n */\nexport const contains = (el, child) => el !== child && el.contains(child)\n\n/**\n * Removes all children from element\n * @param {Node} el The element to empty\n */\nexport const empty = el => {\n  while (el.firstChild) el.removeChild(el.firstChild)\n}\n\n/**\n * Remove element from the DOM\n * @param {Node} el The element to remove\n */\nexport const remove = el => {\n  el.parentNode.removeChild(el)\n}\n\n/**\n * Get the distance between an element and the top of the page\n * @param  {Node} el The element to check\n * @return {Number}  The distance from the top of the page\n */\nexport const fromTop = el => el.getBoundingClientRect().top + window.scrollY\n\n/**\n * Show selected element\n * @param {Node} el The element to show\n */\nexport const show = el => {\n  el.style.display = ''\n}\n\n/**\n * Hide selected element\n * @param {Node} el The element to hide\n */\nexport const hide = el => {\n  el.style.display = 'none'\n}\n\n/**\n * Toggle visibility of selected element\n * @param {Node} el The element to toggle\n */\nexport const toggle = el => {\n  el.style.display = el.style.display == 'none' ? '' : 'none'\n}\n\n/**\n * Apply multiple inline styles to an element\n * @param {Node} el    The element to apply the styles to\n * @param {Object} obj An object of CSS rules\n */\nexport const css = (el, obj) => {\n  for (let rule in obj) {\n    el.style[rule] = obj[rule]\n  }\n}\n\n/**\n * Apply propagating event handlers\n * @param {String} event    The event to trigger on\n * @param {Array} array     The array of nodes to apply to\n * @param {String} selector Query selector for event to bind to [optional]\n * @param {Function} cb     The function to run upon event trigger\n */\nexport const on = (event, array, selector, cb) => {\n  cb = typeof selector === 'function' ? selector : cb\n  array = array.length ? array : [array]\n\n  const listener = function(e) {\n    if (typeof selector === 'string') {\n      if (e.target.closest(selector)) {\n        cb.apply(e.target.closest(selector), [e])\n      }\n    } else {\n      cb.apply(this, [e])\n    }\n  }\n\n  array.forEach(item => {\n    item.addEventListener(event, listener)\n  })\n}\n\n/**\n * Run callback function once DOM has fully loaded\n * @param {Function} cb The function to run once ready\n */\nexport const ready = cb => {\n  if (document.readyState != 'loading') cb()\n  else if (document.addEventListener)\n    document.addEventListener('DOMContentLoaded', cb)\n  else\n    document.attachEvent('onreadystatechange', () => {\n      if (document.readyState == 'complete') cb()\n    })\n}\n"],"names":["selector","scope","document","querySelector","slice","call","querySelectorAll","array","count","reverse","let","newArray","i","push","length","values","forEach","value","filter","item","el","children","nodeType","unshift","siblings","Array","prototype","parentNode","splice","child","contains","firstChild","removeChild","getBoundingClientRect","top","window","scrollY","style","display","obj","rule","event","cb","const","listener","e","target","closest","apply","this","addEventListener","readyState","attachEvent"],"mappings":"6LAMmBA,EAAUC,yBAAQC,UAAaD,EAAME,cAAcH,mBAQlDA,EAAUC,yBAAQC,aACjCE,MAAMC,KAAKJ,EAAMK,iBAAiBN,sBASjBO,EAAOC,EAAOC,GAClC,IAAKD,EAAO,OAAOD,EAAM,GAGzB,IADAG,IAAIC,KACKC,EAAI,EAAGA,EAAIJ,EAAOI,IAAKD,EAASE,KAAKN,EAAMK,IACpD,OAAOH,EAAUE,EAASF,UAAYE,mBAUnBJ,EAAOC,EAAOC,GACjC,IAAKD,EAAO,OAAOD,EAAMA,EAAMO,OAAS,GAGxC,IADAJ,IAAIC,KACKC,EAAI,EAAGA,GAAKJ,EAAOI,IAAKD,EAASE,KAAKN,EAAMA,EAAMO,OAASF,IACpE,OAAOH,EAAUE,EAAWA,EAASF,4BASjBF,iEAIpB,OAHAQ,EAAOC,iBAAQC,GACbV,EAAQA,EAAMW,gBAAOC,UAAQA,IAASF,MAEjCV,uBAQea,GAEtB,IADAV,IAAIW,KACKT,EAAIQ,EAAGC,SAASP,OAAQF,KACA,GAA3BQ,EAAGC,SAAST,GAAGU,UAAeD,EAASE,QAAQH,EAAGC,SAAST,IAEjE,OAAOS,uBAQeD,GAEtB,IADAV,IAAIc,EAAWC,MAAMC,UAAUtB,MAAMC,KAAKe,EAAGO,WAAWN,UAC/CT,EAAIY,EAASV,OAAQF,KAC5B,GAAIY,EAASZ,KAAOQ,EAAI,CACtBI,EAASI,OAAOhB,EAAG,GACnB,MAGJ,OAAOY,uBASgBJ,EAAIS,UAAUT,IAAOS,GAAST,EAAGU,SAASD,qBAM9CT,GACnB,KAAOA,EAAGW,YAAYX,EAAGY,YAAYZ,EAAGW,+BAOpBX,GACpBA,EAAGO,WAAWK,YAAYZ,uBAQLA,UAAMA,EAAGa,wBAAwBC,IAAMC,OAAOC,yBAMjDhB,GAClBA,EAAGiB,MAAMC,QAAU,oBAODlB,GAClBA,EAAGiB,MAAMC,QAAU,0BAOClB,GACpBA,EAAGiB,MAAMC,QAA8B,QAApBlB,EAAGiB,MAAMC,QAAoB,GAAK,uBAQnClB,EAAImB,GACtB,IAAK7B,IAAI8B,KAAQD,EACfnB,EAAGiB,MAAMG,GAAQD,EAAIC,kBAWNC,EAAOlC,EAAOP,EAAU0C,GACzCA,EAAyB,mBAAb1C,EAA0BA,EAAW0C,EAGjDC,IAAMC,EAAW,SAASC,GACA,iBAAb7C,EACL6C,EAAEC,OAAOC,QAAQ/C,IACnB0C,EAAGM,MAAMH,EAAEC,OAAOC,QAAQ/C,IAAY6C,IAGxCH,EAAGM,MAAMC,MAAOJ,MARpBtC,EAAQA,EAAMO,OAASP,GAASA,IAY1BS,iBAAQG,GACZA,EAAK+B,iBAAiBT,EAAOG,uBAQZF,GACQ,WAAvBxC,SAASiD,WAAyBT,IAC7BxC,SAASgD,iBAChBhD,SAASgD,iBAAiB,mBAAoBR,GAE9CxC,SAASkD,YAAY,gCACQ,YAAvBlD,SAASiD,YAA0BT"}